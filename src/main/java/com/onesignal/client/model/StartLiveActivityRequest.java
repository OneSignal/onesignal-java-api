/*
 * OneSignal
 * A powerful way to send personalized messages at scale and build effective customer engagement strategies. Learn more at onesignal.com
 *
 * The version of the OpenAPI document: 5.3.0
 * Contact: devrel@onesignal.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.onesignal.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.onesignal.client.model.FilterExpression;
import com.onesignal.client.model.LanguageStringMap;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.jackson.nullable.JsonNullable;
import java.io.Serializable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.onesignal.client.JSON;

/**
 * StartLiveActivityRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class StartLiveActivityRequest {
  private static final long serialVersionUID = 1L;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  /**
   * Gets or Sets event
   */
  @JsonAdapter(EventEnum.Adapter.class)
  public enum EventEnum {
    START("start");

    private String value;

    EventEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static EventEnum fromValue(String value) {
      for (EventEnum b : EventEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<EventEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final EventEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public EventEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return EventEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_EVENT = "event";
  @SerializedName(SERIALIZED_NAME_EVENT)
  private EventEnum event = EventEnum.START;

  public static final String SERIALIZED_NAME_ACTIVITY_ID = "activity_id";
  @SerializedName(SERIALIZED_NAME_ACTIVITY_ID)
  private String activityId;

  public static final String SERIALIZED_NAME_EVENT_ATTRIBUTES = "event_attributes";
  @SerializedName(SERIALIZED_NAME_EVENT_ATTRIBUTES)
  private Object eventAttributes;

  public static final String SERIALIZED_NAME_EVENT_UPDATES = "event_updates";
  @SerializedName(SERIALIZED_NAME_EVENT_UPDATES)
  private Object eventUpdates;

  public static final String SERIALIZED_NAME_CONTENTS = "contents";
  @SerializedName(SERIALIZED_NAME_CONTENTS)
  private LanguageStringMap contents;

  public static final String SERIALIZED_NAME_HEADINGS = "headings";
  @SerializedName(SERIALIZED_NAME_HEADINGS)
  private LanguageStringMap headings;

  public static final String SERIALIZED_NAME_STALE_DATE = "stale_date";
  @SerializedName(SERIALIZED_NAME_STALE_DATE)
  private Integer staleDate;

  public static final String SERIALIZED_NAME_PRIORITY = "priority";
  @SerializedName(SERIALIZED_NAME_PRIORITY)
  private Integer priority;

  public static final String SERIALIZED_NAME_IOS_RELEVANCE_SCORE = "ios_relevance_score";
  @SerializedName(SERIALIZED_NAME_IOS_RELEVANCE_SCORE)
  private BigDecimal iosRelevanceScore;

  public static final String SERIALIZED_NAME_IDEMPOTENCY_KEY = "idempotency_key";
  @SerializedName(SERIALIZED_NAME_IDEMPOTENCY_KEY)
  private String idempotencyKey;

  public static final String SERIALIZED_NAME_INCLUDE_ALIASES = "include_aliases";
  @SerializedName(SERIALIZED_NAME_INCLUDE_ALIASES)
  private Map<String, List<String>> includeAliases = null;

  public static final String SERIALIZED_NAME_INCLUDE_SUBSCRIPTION_IDS = "include_subscription_ids";
  @SerializedName(SERIALIZED_NAME_INCLUDE_SUBSCRIPTION_IDS)
  private List<String> includeSubscriptionIds = null;

  public static final String SERIALIZED_NAME_INCLUDED_SEGMENTS = "included_segments";
  @SerializedName(SERIALIZED_NAME_INCLUDED_SEGMENTS)
  private List<String> includedSegments = null;

  public static final String SERIALIZED_NAME_EXCLUDED_SEGMENTS = "excluded_segments";
  @SerializedName(SERIALIZED_NAME_EXCLUDED_SEGMENTS)
  private List<String> excludedSegments = null;

  public static final String SERIALIZED_NAME_FILTERS = "filters";
  @SerializedName(SERIALIZED_NAME_FILTERS)
  private List<FilterExpression> filters = null;

  public StartLiveActivityRequest() { 
  }

  public StartLiveActivityRequest name(String name) {
    
    this.name = name;
    return this;
  }

   /**
   * An internal name to assist with your campaign organization. This does not get displayed in the message itself.
   * @return name
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "An internal name to assist with your campaign organization. This does not get displayed in the message itself.")

  public String getName() {
    return name;
  }


  public void setName(String name) {
    this.name = name;
  }


  public StartLiveActivityRequest event(EventEnum event) {
    
    this.event = event;
    return this;
  }

   /**
   * Get event
   * @return event
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public EventEnum getEvent() {
    return event;
  }


  public void setEvent(EventEnum event) {
    this.event = event;
  }


  public StartLiveActivityRequest activityId(String activityId) {
    
    this.activityId = activityId;
    return this;
  }

   /**
   * Set a unique activity_id to track and manage the Live Activity.
   * @return activityId
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Set a unique activity_id to track and manage the Live Activity.")

  public String getActivityId() {
    return activityId;
  }


  public void setActivityId(String activityId) {
    this.activityId = activityId;
  }


  public StartLiveActivityRequest eventAttributes(Object eventAttributes) {
    
    this.eventAttributes = eventAttributes;
    return this;
  }

   /**
   * Default/static data to initialize the Live Activity upon start.
   * @return eventAttributes
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Default/static data to initialize the Live Activity upon start.")

  public Object getEventAttributes() {
    return eventAttributes;
  }


  public void setEventAttributes(Object eventAttributes) {
    this.eventAttributes = eventAttributes;
  }


  public StartLiveActivityRequest eventUpdates(Object eventUpdates) {
    
    this.eventUpdates = eventUpdates;
    return this;
  }

   /**
   * Dynamic content used to update the running Live Activity at start. Must match the ContentState interface defined in your app.
   * @return eventUpdates
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Dynamic content used to update the running Live Activity at start. Must match the ContentState interface defined in your app.")

  public Object getEventUpdates() {
    return eventUpdates;
  }


  public void setEventUpdates(Object eventUpdates) {
    this.eventUpdates = eventUpdates;
  }


  public StartLiveActivityRequest contents(LanguageStringMap contents) {
    
    this.contents = contents;
    return this;
  }

   /**
   * Get contents
   * @return contents
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public LanguageStringMap getContents() {
    return contents;
  }


  public void setContents(LanguageStringMap contents) {
    this.contents = contents;
  }


  public StartLiveActivityRequest headings(LanguageStringMap headings) {
    
    this.headings = headings;
    return this;
  }

   /**
   * Get headings
   * @return headings
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public LanguageStringMap getHeadings() {
    return headings;
  }


  public void setHeadings(LanguageStringMap headings) {
    this.headings = headings;
  }


  public StartLiveActivityRequest staleDate(Integer staleDate) {
    
    this.staleDate = staleDate;
    return this;
  }

   /**
   * Accepts Unix timestamp in seconds. When time reaches the configured stale date, the system considers the Live Activity out of date, and the ActivityState of the Live Activity changes to ActivityState.stale.
   * @return staleDate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Accepts Unix timestamp in seconds. When time reaches the configured stale date, the system considers the Live Activity out of date, and the ActivityState of the Live Activity changes to ActivityState.stale.")

  public Integer getStaleDate() {
    return staleDate;
  }


  public void setStaleDate(Integer staleDate) {
    this.staleDate = staleDate;
  }


  public StartLiveActivityRequest priority(Integer priority) {
    
    this.priority = priority;
    return this;
  }

   /**
   * Delivery priority through the push provider (APNs). Pass 10 for higher priority notifications, or 5 for lower priority notifications. Lower priority notifications are sent based on the power considerations of the end user&#39;s device. If not set, defaults to 10.
   * @return priority
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Delivery priority through the push provider (APNs). Pass 10 for higher priority notifications, or 5 for lower priority notifications. Lower priority notifications are sent based on the power considerations of the end user's device. If not set, defaults to 10.")

  public Integer getPriority() {
    return priority;
  }


  public void setPriority(Integer priority) {
    this.priority = priority;
  }


  public StartLiveActivityRequest iosRelevanceScore(BigDecimal iosRelevanceScore) {
    
    this.iosRelevanceScore = iosRelevanceScore;
    return this;
  }

   /**
   * iOS 15+. A score to indicate how a notification should be displayed when grouped. Use a float between 0-1.
   * @return iosRelevanceScore
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "iOS 15+. A score to indicate how a notification should be displayed when grouped. Use a float between 0-1.")

  public BigDecimal getIosRelevanceScore() {
    return iosRelevanceScore;
  }


  public void setIosRelevanceScore(BigDecimal iosRelevanceScore) {
    this.iosRelevanceScore = iosRelevanceScore;
  }


  public StartLiveActivityRequest idempotencyKey(String idempotencyKey) {
    
    this.idempotencyKey = idempotencyKey;
    return this;
  }

   /**
   * Correlation and idempotency key. A request received with this parameter will first look for another notification with the same idempotency key. If one exists, a notification will not be sent, and result of the previous operation will instead be returned. Therefore, if you plan on using this feature, it&#39;s important to use a good source of randomness to generate the UUID passed here. This key is only idempotent for 30 days. After 30 days, the notification could be removed from our system and a notification with the same idempotency key will be sent again.   See Idempotent Notification Requests for more details writeOnly: true 
   * @return idempotencyKey
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Correlation and idempotency key. A request received with this parameter will first look for another notification with the same idempotency key. If one exists, a notification will not be sent, and result of the previous operation will instead be returned. Therefore, if you plan on using this feature, it's important to use a good source of randomness to generate the UUID passed here. This key is only idempotent for 30 days. After 30 days, the notification could be removed from our system and a notification with the same idempotency key will be sent again.   See Idempotent Notification Requests for more details writeOnly: true ")

  public String getIdempotencyKey() {
    return idempotencyKey;
  }


  public void setIdempotencyKey(String idempotencyKey) {
    this.idempotencyKey = idempotencyKey;
  }


  public StartLiveActivityRequest includeAliases(Map<String, List<String>> includeAliases) {
    
    this.includeAliases = includeAliases;
    return this;
  }

  public StartLiveActivityRequest putIncludeAliasesItem(String key, List<String> includeAliasesItem) {
    if (this.includeAliases == null) {
      this.includeAliases = new HashMap<>();
    }
    this.includeAliases.put(key, includeAliasesItem);
    return this;
  }

   /**
   * Target specific users by aliases assigned via API. An alias can be an external_id, onesignal_id, or a custom alias. Accepts an object where keys are alias labels and values are arrays of alias IDs to include Example usage: { \&quot;external_id\&quot;: [\&quot;exId1\&quot;, \&quot;extId2\&quot;], \&quot;internal_label\&quot;: [\&quot;id1\&quot;, \&quot;id2\&quot;] } Not compatible with any other targeting parameters. REQUIRED: REST API Key Authentication Limit of 2,000 entries per REST API call Note: If targeting push, email, or sms subscribers with same ids, use with target_channel to indicate you are sending a push or email or sms.
   * @return includeAliases
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Target specific users by aliases assigned via API. An alias can be an external_id, onesignal_id, or a custom alias. Accepts an object where keys are alias labels and values are arrays of alias IDs to include Example usage: { \"external_id\": [\"exId1\", \"extId2\"], \"internal_label\": [\"id1\", \"id2\"] } Not compatible with any other targeting parameters. REQUIRED: REST API Key Authentication Limit of 2,000 entries per REST API call Note: If targeting push, email, or sms subscribers with same ids, use with target_channel to indicate you are sending a push or email or sms.")

  public Map<String, List<String>> getIncludeAliases() {
    return includeAliases;
  }


  public void setIncludeAliases(Map<String, List<String>> includeAliases) {
    this.includeAliases = includeAliases;
  }


  public StartLiveActivityRequest includeSubscriptionIds(List<String> includeSubscriptionIds) {
    
    this.includeSubscriptionIds = includeSubscriptionIds;
    return this;
  }

  public StartLiveActivityRequest addIncludeSubscriptionIdsItem(String includeSubscriptionIdsItem) {
    if (this.includeSubscriptionIds == null) {
      this.includeSubscriptionIds = new ArrayList<>();
    }
    this.includeSubscriptionIds.add(includeSubscriptionIdsItem);
    return this;
  }

   /**
   * Specific subscription ids to target. Not compatible with other targeting parameters.
   * @return includeSubscriptionIds
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specific subscription ids to target. Not compatible with other targeting parameters.")

  public List<String> getIncludeSubscriptionIds() {
    return includeSubscriptionIds;
  }


  public void setIncludeSubscriptionIds(List<String> includeSubscriptionIds) {
    this.includeSubscriptionIds = includeSubscriptionIds;
  }


  public StartLiveActivityRequest includedSegments(List<String> includedSegments) {
    
    this.includedSegments = includedSegments;
    return this;
  }

  public StartLiveActivityRequest addIncludedSegmentsItem(String includedSegmentsItem) {
    if (this.includedSegments == null) {
      this.includedSegments = new ArrayList<>();
    }
    this.includedSegments.add(includedSegmentsItem);
    return this;
  }

   /**
   * Segment names to include. Only compatible with excluded_segments.
   * @return includedSegments
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Segment names to include. Only compatible with excluded_segments.")

  public List<String> getIncludedSegments() {
    return includedSegments;
  }


  public void setIncludedSegments(List<String> includedSegments) {
    this.includedSegments = includedSegments;
  }


  public StartLiveActivityRequest excludedSegments(List<String> excludedSegments) {
    
    this.excludedSegments = excludedSegments;
    return this;
  }

  public StartLiveActivityRequest addExcludedSegmentsItem(String excludedSegmentsItem) {
    if (this.excludedSegments == null) {
      this.excludedSegments = new ArrayList<>();
    }
    this.excludedSegments.add(excludedSegmentsItem);
    return this;
  }

   /**
   * Segment names to exclude. Only compatible with included_segments.
   * @return excludedSegments
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Segment names to exclude. Only compatible with included_segments.")

  public List<String> getExcludedSegments() {
    return excludedSegments;
  }


  public void setExcludedSegments(List<String> excludedSegments) {
    this.excludedSegments = excludedSegments;
  }


  public StartLiveActivityRequest filters(List<FilterExpression> filters) {
    
    this.filters = filters;
    return this;
  }

  public StartLiveActivityRequest addFiltersItem(FilterExpression filtersItem) {
    if (this.filters == null) {
      this.filters = new ArrayList<>();
    }
    this.filters.add(filtersItem);
    return this;
  }

   /**
   * Get filters
   * @return filters
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public List<FilterExpression> getFilters() {
    return filters;
  }


  public void setFilters(List<FilterExpression> filters) {
    this.filters = filters;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    StartLiveActivityRequest startLiveActivityRequest = (StartLiveActivityRequest) o;
    return Objects.equals(this.name, startLiveActivityRequest.name) &&
        Objects.equals(this.event, startLiveActivityRequest.event) &&
        Objects.equals(this.activityId, startLiveActivityRequest.activityId) &&
        Objects.equals(this.eventAttributes, startLiveActivityRequest.eventAttributes) &&
        Objects.equals(this.eventUpdates, startLiveActivityRequest.eventUpdates) &&
        Objects.equals(this.contents, startLiveActivityRequest.contents) &&
        Objects.equals(this.headings, startLiveActivityRequest.headings) &&
        Objects.equals(this.staleDate, startLiveActivityRequest.staleDate) &&
        Objects.equals(this.priority, startLiveActivityRequest.priority) &&
        Objects.equals(this.iosRelevanceScore, startLiveActivityRequest.iosRelevanceScore) &&
        Objects.equals(this.idempotencyKey, startLiveActivityRequest.idempotencyKey) &&
        Objects.equals(this.includeAliases, startLiveActivityRequest.includeAliases) &&
        Objects.equals(this.includeSubscriptionIds, startLiveActivityRequest.includeSubscriptionIds) &&
        Objects.equals(this.includedSegments, startLiveActivityRequest.includedSegments) &&
        Objects.equals(this.excludedSegments, startLiveActivityRequest.excludedSegments) &&
        Objects.equals(this.filters, startLiveActivityRequest.filters);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, event, activityId, eventAttributes, eventUpdates, contents, headings, staleDate, priority, iosRelevanceScore, idempotencyKey, includeAliases, includeSubscriptionIds, includedSegments, excludedSegments, filters);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class StartLiveActivityRequest {\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    event: ").append(toIndentedString(event)).append("\n");
    sb.append("    activityId: ").append(toIndentedString(activityId)).append("\n");
    sb.append("    eventAttributes: ").append(toIndentedString(eventAttributes)).append("\n");
    sb.append("    eventUpdates: ").append(toIndentedString(eventUpdates)).append("\n");
    sb.append("    contents: ").append(toIndentedString(contents)).append("\n");
    sb.append("    headings: ").append(toIndentedString(headings)).append("\n");
    sb.append("    staleDate: ").append(toIndentedString(staleDate)).append("\n");
    sb.append("    priority: ").append(toIndentedString(priority)).append("\n");
    sb.append("    iosRelevanceScore: ").append(toIndentedString(iosRelevanceScore)).append("\n");
    sb.append("    idempotencyKey: ").append(toIndentedString(idempotencyKey)).append("\n");
    sb.append("    includeAliases: ").append(toIndentedString(includeAliases)).append("\n");
    sb.append("    includeSubscriptionIds: ").append(toIndentedString(includeSubscriptionIds)).append("\n");
    sb.append("    includedSegments: ").append(toIndentedString(includedSegments)).append("\n");
    sb.append("    excludedSegments: ").append(toIndentedString(excludedSegments)).append("\n");
    sb.append("    filters: ").append(toIndentedString(filters)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("name");
    openapiFields.add("event");
    openapiFields.add("activity_id");
    openapiFields.add("event_attributes");
    openapiFields.add("event_updates");
    openapiFields.add("contents");
    openapiFields.add("headings");
    openapiFields.add("stale_date");
    openapiFields.add("priority");
    openapiFields.add("ios_relevance_score");
    openapiFields.add("idempotency_key");
    openapiFields.add("include_aliases");
    openapiFields.add("include_subscription_ids");
    openapiFields.add("included_segments");
    openapiFields.add("excluded_segments");
    openapiFields.add("filters");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("name");
    openapiRequiredFields.add("event");
    openapiRequiredFields.add("activity_id");
    openapiRequiredFields.add("event_attributes");
    openapiRequiredFields.add("event_updates");
    openapiRequiredFields.add("contents");
    openapiRequiredFields.add("headings");
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!StartLiveActivityRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'StartLiveActivityRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<StartLiveActivityRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(StartLiveActivityRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<StartLiveActivityRequest>() {
           @Override
           public void write(JsonWriter out, StartLiveActivityRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public StartLiveActivityRequest read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();

             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of StartLiveActivityRequest given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of StartLiveActivityRequest
  * @throws IOException if the JSON string is invalid with respect to StartLiveActivityRequest
  */
  public static StartLiveActivityRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, StartLiveActivityRequest.class);
  }

 /**
  * Convert an instance of StartLiveActivityRequest to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

